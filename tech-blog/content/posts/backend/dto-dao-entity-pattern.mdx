---
title: "[Backend] DTO, DAO, Entity íŒ¨í„´ ì´í•´í•˜ê¸°"
description: "ë°±ì—”ë“œ ì•„í‚¤í…ì²˜ì˜ í•µì‹¬ íŒ¨í„´ì¸ DTO, DAO, Entityì˜ ê°œë…ê³¼ ì‹¤ë¬´ ì ìš© ë°©ë²•"
category: "backend"
tags: ["backend", "architecture", "dto", "dao", "entity", "nestjs"]
createdAt: "2025-12-26"
updatedAt: "2025-12-26"
published: true
---

## DTO, DAO, Entity íŒ¨í„´ ì´í•´í•˜ê¸°

ë°±ì—”ë“œ ê°œë°œì„ í•˜ë‹¤ ë³´ë©´ DTO, DAO, Entity, VO, BO ê°™ì€ ìš©ì–´ë“¤ì„ ìì£¼ ì ‘í•˜ê²Œ ë©ë‹ˆë‹¤. ì²˜ìŒì—” ë¹„ìŠ·í•´ ë³´ì—¬ì„œ í˜¼ë€ìŠ¤ëŸ¬ìš´ë°, ê°ê°ì˜ ì—­í• ì„ ëª…í™•íˆ ì´í•´í•˜ë©´ ì½”ë“œ êµ¬ì¡°ê°€ í›¨ì”¬ ê¹”ë”í•´ì§‘ë‹ˆë‹¤.

---

## í•œëˆˆì— ë³´ëŠ” ê° íŒ¨í„´ì˜ ì—­í• 

```mermaid
flowchart LR
    subgraph Client["ğŸ‘¤ í´ë¼ì´ì–¸íŠ¸"]
        REQ[ìš”ì²­]
    end

    subgraph Controller["ğŸ® Controller"]
        DTO_IN["Request DTO<br/>(ì…ë ¥ ê²€ì¦)"]
    end

    subgraph Service["âš™ï¸ Service"]
        LOGIC["ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§"]
    end

    subgraph Repository["ğŸ’¾ Repository/DAO"]
        ACCESS["ë°ì´í„° ì ‘ê·¼"]
    end

    subgraph Database["ğŸ—„ï¸ Database"]
        ENTITY["Entity<br/>(í…Œì´ë¸” ë§¤í•‘)"]
    end

    REQ --> DTO_IN
    DTO_IN --> LOGIC
    LOGIC --> ACCESS
    ACCESS <--> ENTITY

    style Client fill:#E0FFFF
    style Controller fill:#FFE4E1
    style Service fill:#FFF8DC
    style Repository fill:#E8F8E8
    style Database fill:#DDA0DD
```

| íŒ¨í„´ | ì—­í•  | ë¹„ìœ  |
|------|------|------|
| **DTO** | ë°ì´í„° ìš´ë°˜ | íƒë°° ìƒì ğŸ“¦ |
| **DAO/Repository** | DB ì ‘ê·¼ ë¡œì§ | ì°½ê³  ê´€ë¦¬ì ğŸ‘· |
| **Entity** | DB í…Œì´ë¸” ë§¤í•‘ | ì°½ê³  ë¬¼ê±´ ğŸ·ï¸ |
| **VO** | ê°’ ê°ì²´ (ë¶ˆë³€) | í™”í ğŸ’µ |
| **BO** | ë¹„ì¦ˆë‹ˆìŠ¤ ê°ì²´ | ê³„ì‚°ê¸° ğŸ§® |

---

## DTO (Data Transfer Object)

### í•µì‹¬ ê°œë…

DTOëŠ” **ë ˆì´ì–´ ê°„ ë°ì´í„°ë¥¼ ì „ë‹¬í•˜ëŠ” ê°ì²´**ì…ë‹ˆë‹¤. ìˆœìˆ˜í•˜ê²Œ ë°ì´í„°ë§Œ ë‹´ê³  ìˆìœ¼ë©°, ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ ì—†ìŠµë‹ˆë‹¤.

```mermaid
flowchart LR
    subgraph Client["í´ë¼ì´ì–¸íŠ¸"]
        JSON["{ name: 'í™ê¸¸ë™', age: 25 }"]
    end

    subgraph Server["ì„œë²„"]
        DTO["CreateUserDto"]
        SVC["UserService"]
    end

    JSON -->|"Request"| DTO
    DTO -->|"ê²€ì¦ ì™„ë£Œ"| SVC
    SVC -->|"Response"| JSON2["UserResponseDto"]

    style DTO fill:#FFE4E1
    style JSON2 fill:#E8F8E8
```

### ë¹„ìœ ë¡œ ì´í•´í•˜ê¸°

> DTOëŠ” **íƒë°° ìƒì**ì™€ ê°™ìŠµë‹ˆë‹¤.
> - ë‚´ìš©ë¬¼(ë°ì´í„°)ë§Œ ë‹´ê²¨ ìˆìŒ
> - ë°°ì†¡(ì „ì†¡) ëª©ì ìœ¼ë¡œë§Œ ì‚¬ìš©
> - ìƒì ìì²´ëŠ” ì•„ë¬´ ê¸°ëŠ¥ì´ ì—†ìŒ

### Request DTO ì˜ˆì‹œ (NestJS)

```typescript
// create-user.dto.ts
import { IsEmail, IsInt, IsString, Min, Max } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateUserDto {
  @ApiProperty({ description: 'ì‚¬ìš©ì ì´ë¦„' })
  @IsString()
  name: string;

  @ApiProperty({ description: 'ì´ë©”ì¼ ì£¼ì†Œ' })
  @IsEmail()
  email: string;

  @ApiProperty({ description: 'ë‚˜ì´', minimum: 1, maximum: 150 })
  @IsInt()
  @Min(1)
  @Max(150)
  age: number;
}
```

### Response DTO ì˜ˆì‹œ

```typescript
// user-response.dto.ts
export interface UserResponseDto {
  id: number;
  name: string;
  email: string;
  createdAt: string;
}
```

### Request DTO vs Response DTO

| êµ¬ë¶„ | Request DTO | Response DTO |
|------|-------------|--------------|
| **ìš©ë„** | í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„ | ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸ |
| **í˜•íƒœ** | class + ë°ì½”ë ˆì´í„° | interface ê°€ëŠ¥ |
| **ìœ íš¨ì„± ê²€ì‚¬** | âœ… í•„ìš” | âŒ ë¶ˆí•„ìš” |
| **NestJS ë°ì½”ë ˆì´í„°** | @IsString, @IsInt ë“± | ì„ íƒì  |

---

## DAO (Data Access Object) / Repository

### í•µì‹¬ ê°œë…

DAOëŠ” **ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼ ë¡œì§ì„ ìº¡ìŠí™”**í•˜ëŠ” ê°ì²´ì…ë‹ˆë‹¤. CRUD ë©”ì„œë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤.

```mermaid
flowchart LR
    subgraph Service["Service Layer"]
        SVC["UserService"]
    end

    subgraph DAO["DAO/Repository Layer"]
        REPO["UserRepository"]
        METHODS["find()<br/>create()<br/>update()<br/>delete()"]
    end

    subgraph DB["Database"]
        TABLE[(users í…Œì´ë¸”)]
    end

    SVC -->|"findById(1)"| REPO
    REPO --> METHODS
    METHODS <-->|"SQL"| TABLE

    style DAO fill:#E8F8E8
```

### ë¹„ìœ ë¡œ ì´í•´í•˜ê¸°

> DAOëŠ” **ì°½ê³  ê´€ë¦¬ì**ì™€ ê°™ìŠµë‹ˆë‹¤.
> - ë¬¼ê±´(ë°ì´í„°)ì„ ì €ì¥, ì¡°íšŒ, ìˆ˜ì •, ì‚­ì œ
> - ì°½ê³ (DB) ë‚´ë¶€ êµ¬ì¡°ëŠ” ê´€ë¦¬ìë§Œ ì•Œë©´ ë¨
> - ì™¸ë¶€ì—ì„œëŠ” "ì´ê±° ê°€ì ¸ì™€" í•˜ë©´ ë¨

### Prismaì—ì„œì˜ DAO

Prismaë¥¼ ì‚¬ìš©í•˜ë©´ DAOë¥¼ ì§ì ‘ êµ¬í˜„í•  í•„ìš”ê°€ ê±°ì˜ ì—†ìŠµë‹ˆë‹¤. Prisma Clientê°€ DAO ì—­í• ì„ í•©ë‹ˆë‹¤.

```typescript
// ì „í†µì ì¸ DAO íŒ¨í„´ (ì§ì ‘ êµ¬í˜„)
class UserDAO {
  async findById(id: number): Promise<User | null> {
    return db.query('SELECT * FROM users WHERE id = ?', [id]);
  }
  
  async create(data: CreateUserData): Promise<User> {
    return db.query('INSERT INTO users...', [data]);
  }
}

// Prisma ì‚¬ìš© ì‹œ (Prismaê°€ DAO ì—­í• )
class UserService {
  async findById(id: number) {
    return this.prisma.user.findUnique({ where: { id } });
  }
  
  async create(data: CreateUserDto) {
    return this.prisma.user.create({ data });
  }
}
```

---

## Entity

### í•µì‹¬ ê°œë…

EntityëŠ” **ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸”ê³¼ 1:1ë¡œ ë§¤í•‘ë˜ëŠ” ê°ì²´**ì…ë‹ˆë‹¤. ê³ ìœ  ì‹ë³„ì(ID)ë¥¼ ê°€ì§‘ë‹ˆë‹¤.

```mermaid
flowchart LR
    subgraph Code["ì½”ë“œ"]
        ENTITY["User Entity<br/>- id: number<br/>- name: string<br/>- email: string"]
    end

    subgraph DB["ë°ì´í„°ë² ì´ìŠ¤"]
        TABLE["users í…Œì´ë¸”<br/>â”œâ”€ id (PK)<br/>â”œâ”€ name<br/>â””â”€ email"]
    end

    ENTITY <-->|"ORM ë§¤í•‘"| TABLE

    style ENTITY fill:#FFE4E1
    style TABLE fill:#E8F8E8
```

### Prismaì—ì„œì˜ Entity

Prismaì—ì„œëŠ” `schema.prisma`ì— ëª¨ë¸ì„ ì •ì˜í•˜ë©´ Entityê°€ ìë™ ìƒì„±ë©ë‹ˆë‹¤.

```prisma
// prisma/schema.prisma
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
}

model Post {
  id       Int    @id @default(autoincrement())
  title    String
  content  String?
  author   User   @relation(fields: [authorId], references: [id])
  authorId Int
}
```

### Entity vs DTO

| êµ¬ë¶„ | Entity | DTO |
|------|--------|-----|
| **ëª©ì ** | DB í…Œì´ë¸” ë§¤í•‘ | ë°ì´í„° ì „ì†¡ |
| **ìœ„ì¹˜** | Repository/DB ë ˆì´ì–´ | Controller/Service ë ˆì´ì–´ |
| **ê´€ê³„** | ë‹¤ë¥¸ Entityì™€ ê´€ê³„ ê°€ì§ | ê´€ê³„ ì—†ìŒ (í‰íƒ„í™”) |
| **ID** | í•„ìˆ˜ (ê³ ìœ  ì‹ë³„ì) | ì„ íƒì  |

```mermaid
flowchart TB
    subgraph Entity["Entity (DB ë ˆì´ì–´)"]
        E1["User"]
        E2["Post"]
        E1 -->|"1:N"| E2
    end

    subgraph DTO["DTO (API ë ˆì´ì–´)"]
        D1["UserResponseDto"]
        D2["PostResponseDto<br/>+ authorName: string"]
    end

    E1 -->|"ë³€í™˜"| D1
    E2 -->|"ë³€í™˜ (í‰íƒ„í™”)"| D2

    style Entity fill:#FFE4E1
    style DTO fill:#E8F8E8
```

---

## VO (Value Object)

### í•µì‹¬ ê°œë…

VOëŠ” **ê°’ ìì²´ë¡œ ë™ë“±ì„±ì„ íŒë‹¨**í•˜ëŠ” ê°ì²´ì…ë‹ˆë‹¤. IDê°€ ì—†ê³ , ë¶ˆë³€(immutable)í•©ë‹ˆë‹¤.

```mermaid
flowchart LR
    subgraph Entityì°¨ì´["Entity vs VO"]
        E["Entity<br/>IDë¡œ ë¹„êµ<br/>user1.id === user2.id"]
        V["VO<br/>ê°’ìœ¼ë¡œ ë¹„êµ<br/>money1.amount === money2.amount"]
    end

    style E fill:#FFE4E1
    style V fill:#E0FFFF
```

### ë¹„ìœ ë¡œ ì´í•´í•˜ê¸°

> VOëŠ” **í™”í**ì™€ ê°™ìŠµë‹ˆë‹¤.
> - 10,000ì›ì§œë¦¬ ë‘ ì¥ì€ ê°™ì€ ê°€ì¹˜ (ê°’ìœ¼ë¡œ ë¹„êµ)
> - ê° ì§€íì˜ ì¼ë ¨ë²ˆí˜¸(ID)ëŠ” ìƒê´€ì—†ìŒ
> - í•œë²ˆ ë°œí–‰ë˜ë©´ ê¸ˆì•¡ ë³€ê²½ ë¶ˆê°€ (ë¶ˆë³€)

### VO ì˜ˆì‹œ

```typescript
// money.vo.ts
class Money {
  constructor(
    private readonly amount: number,
    private readonly currency: string
  ) {}

  // ê°’ìœ¼ë¡œ ë™ë“±ì„± ë¹„êµ
  equals(other: Money): boolean {
    return this.amount === other.amount && 
           this.currency === other.currency;
  }

  // ì—°ì‚°ì€ ìƒˆ ê°ì²´ ë°˜í™˜ (ë¶ˆë³€ì„±)
  add(other: Money): Money {
    if (this.currency !== other.currency) {
      throw new Error('Currency mismatch');
    }
    return new Money(this.amount + other.amount, this.currency);
  }
}

// ì‚¬ìš©
const price1 = new Money(10000, 'KRW');
const price2 = new Money(10000, 'KRW');

console.log(price1.equals(price2)); // true (ê°’ì´ ê°™ìœ¼ë©´ ê°™ìŒ)
console.log(price1 === price2);     // false (ë‹¤ë¥¸ ê°ì²´)
```

### VO í™œìš© ì‚¬ë¡€

| VO | êµ¬ì„± ê°’ | ì‚¬ìš© ì˜ˆì‹œ |
|----|--------|----------|
| `Money` | amount, currency | ê°€ê²©, ê²°ì œ ê¸ˆì•¡ |
| `DateRange` | start, end | ì˜ˆì•½ ê¸°ê°„ |
| `Address` | city, street, zipCode | ë°°ì†¡ ì£¼ì†Œ |
| `Email` | value | ì´ë©”ì¼ (ìœ íš¨ì„± ê²€ì¦ í¬í•¨) |

---

## BO (Business Object)

### í•µì‹¬ ê°œë…

BOëŠ” **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ í¬í•¨í•˜ëŠ” ê°ì²´**ì…ë‹ˆë‹¤. ë„ë©”ì¸ ì§€ì‹ì„ ë‹´ê³  ìˆìŠµë‹ˆë‹¤.

```typescript
// fund.bo.ts
class Fund {
  constructor(
    public readonly id: number,
    public readonly name: string,
    public readonly aum: number,       // ìš´ìš©ìì‚°
    public readonly category: string
  ) {}

  // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
  isLargeCap(): boolean {
    return this.aum >= 1_000_000_000_000; // 1ì¡° ì´ìƒ
  }

  getAumTier(): 'small' | 'medium' | 'large' {
    if (this.aum < 100_000_000_000) return 'small';
    if (this.aum < 1_000_000_000_000) return 'medium';
    return 'large';
  }

  getRiskLevel(): 'low' | 'medium' | 'high' {
    // ì¹´í…Œê³ ë¦¬ì— ë”°ë¥¸ ë¦¬ìŠ¤í¬ ë ˆë²¨ ê³„ì‚°
    const highRiskCategories = ['ì£¼ì‹', 'íŒŒìƒìƒí’ˆ'];
    return highRiskCategories.includes(this.category) 
      ? 'high' 
      : 'low';
  }
}
```

### DTO vs VO vs BO ë¹„êµ

| êµ¬ë¶„ | ë¡œì§ | ë¶ˆë³€ | ID | ìš©ë„ |
|------|------|------|-----|------|
| **DTO** | âŒ ì—†ìŒ | âŒ ì•„ë‹˜ | ì„ íƒ | ë°ì´í„° ì „ì†¡ |
| **VO** | âœ… ë™ë“±ì„± | âœ… ë¶ˆë³€ | âŒ ì—†ìŒ | ê°’ í‘œí˜„ |
| **BO** | âœ… ë¹„ì¦ˆë‹ˆìŠ¤ | âŒ ì•„ë‹˜ | âœ… ìˆìŒ | ë„ë©”ì¸ ë¡œì§ |

---

## ì‹¤ë¬´ ì˜ˆì œ: NestJSì—ì„œì˜ ì ìš©

### ì „ì²´ êµ¬ì¡°

```
src/
â”œâ”€â”€ user/
â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”œâ”€â”€ create-user.dto.ts      # Request DTO
â”‚   â”‚   â””â”€â”€ user-response.dto.ts    # Response DTO
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â””â”€â”€ user.entity.ts          # Entity (Prismaê°€ ëŒ€ì²´)
â”‚   â”œâ”€â”€ user.controller.ts
â”‚   â”œâ”€â”€ user.service.ts
â”‚   â””â”€â”€ user.module.ts
â””â”€â”€ prisma/
    â””â”€â”€ prisma.service.ts           # DAO ì—­í• 
```

### Controller

```typescript
// user.controller.ts
@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post()
  async create(@Body() createUserDto: CreateUserDto): Promise<UserResponseDto> {
    return this.userService.create(createUserDto);
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<UserResponseDto> {
    return this.userService.findOne(+id);
  }
}
```

### Service

```typescript
// user.service.ts
@Injectable()
export class UserService {
  constructor(private readonly prisma: PrismaService) {}

  async create(dto: CreateUserDto): Promise<UserResponseDto> {
    const user = await this.prisma.user.create({
      data: dto,
    });
    return this.toResponseDto(user);
  }

  async findOne(id: number): Promise<UserResponseDto> {
    const user = await this.prisma.user.findUnique({
      where: { id },
    });
    if (!user) throw new NotFoundException();
    return this.toResponseDto(user);
  }

  // Entity â†’ Response DTO ë³€í™˜
  private toResponseDto(user: User): UserResponseDto {
    return {
      id: user.id,
      name: user.name,
      email: user.email,
      createdAt: user.createdAt.toISOString(),
    };
  }
}
```

### ë°ì´í„° íë¦„

```mermaid
sequenceDiagram
    participant C as í´ë¼ì´ì–¸íŠ¸
    participant CT as Controller
    participant S as Service
    participant P as Prisma (DAO)
    participant DB as Database

    C->>CT: POST /users (JSON)
    CT->>CT: CreateUserDtoë¡œ ë³€í™˜ ë° ê²€ì¦
    CT->>S: create(CreateUserDto)
    S->>P: prisma.user.create()
    P->>DB: INSERT INTO users...
    DB-->>P: User (Entity)
    P-->>S: User (Entity)
    S->>S: toResponseDto() ë³€í™˜
    S-->>CT: UserResponseDto
    CT-->>C: JSON Response
```

---

## ë§ˆì¹˜ë©°

DTOëŠ” ë°ì´í„° ì „ì†¡ìš©, DAO/RepositoryëŠ” DB ì ‘ê·¼ ìº¡ìŠí™”, EntityëŠ” DB í…Œì´ë¸” ë§¤í•‘, VOëŠ” ë¶ˆë³€ ê°’ ê°ì²´, BOëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤. NestJS + Prisma ì¡°í•©ì—ì„œëŠ” Request DTOì— classì™€ ë°ì½”ë ˆì´í„°ë¥¼, Response DTOì— interfaceë¥¼ ì‚¬ìš©í•˜ê³ , Entityì™€ DAOëŠ” Prismaê°€ ë‹´ë‹¹í•©ë‹ˆë‹¤.
