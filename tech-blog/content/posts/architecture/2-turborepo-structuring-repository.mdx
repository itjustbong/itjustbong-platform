---
title: "[Turborepo] 2. 레포지토리 구조 잡기 (Structuring a Repository)"
description: "Turborepo 레포지토리 구조 설계 및 패키지 간의 관계 정의"
category: "architecture"
tags: ["turborepo", "monorepo", "build", "optimization"]
createdAt: "2026-01-15"
updatedAt: "2026-01-15"
published: true
---

# Turborepo 레포지토리 구조 잡기 (Structuring a Repository)

Turborepo는 워크스페이스(Workspace) 개념을 기반으로 동작합니다. 이 글에서는 모노레포의 구조를 어떻게 설계하고, 패키지 간의 관계를 어떻게 정의하는지 알아보겠습니다.

## Workspace란?

JavaScript 생태계에서 워크스페이스는 하나 이상의 패키지를 포함하는 프로젝트 구조를 의미합니다. 단일 패키지일 수도 있고, 여러 패키지의 조합일 수도 있습니다.

Turborepo는 이러한 워크스페이스 위에서 작동하며, 각 패키지 매니저(pnpm, npm, yarn)의 워크스페이스 기능을 활용합니다.

## 모노레포 구조 설정하기

### 워크스페이스 패키지 위치 지정

먼저 패키지 매니저에게 어디에 패키지들이 위치하는지 알려줘야 합니다.

```yaml
# pnpm-workspace.yaml
packages:
  - "apps/*"
  - "packages/*"
```

이렇게 설정하면 `apps/`와 `packages/` 디렉토리 하위의 모든 폴더가 패키지로 인식됩니다. 단, 각 폴더에는 반드시 `package.json` 파일이 있어야 합니다.

**현재 프로젝트 구조 예시:**

```
.
├── apps/
│   └── web/                    # Next.js 애플리케이션
│       └── package.json
├── packages/
│   ├── math/                   # 유틸리티 라이브러리
│   │   └── package.json
│   ├── ui/                     # 공유 UI 컴포넌트
│   │   └── package.json
│   ├── typescript-config/      # 공유 TypeScript 설정
│   │   └── package.json
│   └── eslint-config/          # 공유 ESLint 설정
│       └── package.json
├── package.json                # 루트 package.json
└── pnpm-workspace.yaml
```

### 루트 package.json

프로젝트 최상위의 `package.json`은 워크스페이스 전체의 기반이 됩니다.

```json
// ./package.json
{
  "name": "turbo",
  "private": true,
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev",
    "lint": "turbo run lint",
    "check-types": "turbo run check-types"
  },
  "devDependencies": {
    "prettier": "^3.6.2",
    "turbo": "^2.6.1",
    "typescript": "5.9.2"
  },
  "packageManager": "pnpm@9.0.0",
  "engines": {
    "node": ">=18"
  }
}
```

**주요 포인트:**

- **`private: true`**: 루트 패키지는 npm에 배포되지 않도록 설정합니다.
- **`packageManager`**: 팀원들이 동일한 패키지 매니저 버전을 사용하도록 강제합니다.
- **`scripts`**: 모든 워크스페이스에서 실행할 명령어를 정의합니다.

### 루트 turbo.json

Turborepo의 핵심 설정 파일입니다. 태스크 간의 의존성과 캐싱 전략을 정의합니다.

```json
{
  "$schema": "https://turborepo.com/schema.json",
  "ui": "tui",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [".next/**", "!.next/cache/**", "dist/**"]
    },
    "check-types": {
      "dependsOn": ["^check-types"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    }
  }
}
```

이 설정에 대한 자세한 내용은 추후 "태스크 설정하기(Configuring Tasks)" 글에서 다룰 예정입니다.

### Package Manager Lockfile

`pnpm-lock.yaml`, `package-lock.json`, `yarn.lock` 같은 락파일은 워크스페이스 내부 패키지 간의 의존 관계를 추적합니다. Turborepo는 이 파일을 분석하여 패키지 간의 의존성 그래프를 구성합니다.

## Package 이해하기

워크스페이스 내의 각 폴더는 하나의 패키지입니다. 각 패키지는 독립적인 `package.json`을 가지며, 마치 별도의 프로젝트처럼 동작합니다.

### 패키지의 package.json 작성하기

#### name: 고유한 패키지 이름

워크스페이스 내에서 패키지 이름은 반드시 고유해야 합니다. 외부 라이브러리와의 충돌을 방지하기 위해 스코프(scope)를 사용하는 것이 좋습니다.

```json
// packages/math/package.json
{
  "name": "@repo/math",
  "type": "module",
  "scripts": {
    "dev": "tsc --watch",
    "build": "tsc"
  }
}
```

```json
// apps/web/package.json
{
  "name": "web",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@repo/math": "workspace:*",
    "@repo/ui": "workspace:*"
  }
}
```

**네이밍 규칙:**

- `@repo/`, `@acme/` 같은 스코프를 사용하여 내부 패키지임을 명시
- 외부 npm 패키지와 이름이 겹치지 않도록 주의

#### exports: 패키지 진입점 정의

`exports` 필드는 다른 패키지가 현재 패키지를 import할 때 어떤 파일에 접근할 수 있는지 정의합니다.

**현재 프로젝트의 실제 예시:**

```json
// packages/math/package.json
{
  "name": "@repo/math",
  "exports": {
    "./add": {
      "types": "./src/add.ts",
      "default": "./dist/add.js"
    },
    "./subtract": {
      "types": "./src/subtract.ts",
      "default": "./dist/subtract.js"
    }
  }
}
```

```typescript
// packages/math/src/add.ts
export const add = (a: number, b: number) => a + b;
```

```typescript
// packages/math/src/subtract.ts
export const subtract = (a: number, b: number) => a - b;
```

**다른 패키지에서 사용하기:**

```typescript
// apps/web/app/page.tsx
import { add } from '@repo/math/add';
import { subtract } from '@repo/math/subtract';

export default function Page() {
  const sum = add(5, 3);        // 8
  const diff = subtract(10, 4);  // 6

  return <div>Sum: {sum}, Diff: {diff}</div>;
}
```

### exports를 사용하는 이유

#### 1. 배럴 파일(Barrel File) 문제 해결

배럴 파일은 여러 모듈을 한 곳에서 재export하는 패턴입니다.

```typescript
// ❌ 배럴 파일 패턴 (index.ts)
export * from "./Button";
export * from "./Input";
export * from "./Modal";
export * from "./Dropdown";
export * from "./Tooltip";
```

```typescript
// 사용하는 쪽
import { Button } from "./components"; // Button만 필요한데...
```

**문제점:**

1. **불필요한 코드 로드**: Button만 필요해도 번들러가 `index.ts`를 거치면서 모든 파일을 분석해야 합니다.
2. **빌드 속도 저하**: 파일이 많아질수록 분석 시간이 증가합니다.
3. **순환 참조 위험**: Button이 Input을 import하고, Input이 Button을 import하면 순환 참조가 발생할 수 있습니다.

**exports를 사용한 해결:**

```json
{
  "exports": {
    "./button": "./src/Button.tsx",
    "./input": "./src/Input.tsx",
    "./modal": "./src/Modal.tsx"
  }
}
```

```typescript
// 필요한 것만 정확히 import
import { Button } from "@repo/ui/button";
```

이렇게 하면 번들러가 정확히 필요한 파일만 로드하므로 빌드 성능이 향상됩니다.

#### 2. 조건부 Export

환경에 따라 다른 파일을 제공할 수 있습니다.

```json
{
  "exports": {
    ".": {
      "import": "./dist/index.mjs", // ES Module 사용 시
      "require": "./dist/index.cjs", // CommonJS 사용 시
      "types": "./dist/index.d.ts" // TypeScript 타입
    },
    "./client": {
      "browser": "./dist/client.js", // 브라우저 환경
      "node": "./dist/client.node.js" // Node.js 환경
    }
  }
}
```

**활용 사례:**

- 브라우저와 Node.js에서 다른 구현 제공
- 개발/프로덕션 환경에 따른 최적화
- ES Module과 CommonJS 동시 지원

#### 3. IDE 자동완성 지원

`exports`를 정의하면 IDE가 사용 가능한 경로를 자동으로 인식합니다.

```typescript
import { add } from "@repo/math/";
//                              ^ 자동완성: add, subtract
```

### imports: 패키지 내부 경로 별칭

`imports` 필드는 패키지 내부에서 사용하는 경로 별칭을 정의합니다. TypeScript의 `paths` 옵션과 유사하지만, 런타임에서도 동작합니다.

```json
// package.json
{
  "imports": {
    "#utils/*": "./src/utils/*",
    "#components/*": "./src/components/*",
    "#config": "./src/config/index.ts"
  }
}
```

**사용 예시:**

```typescript
// ❌ 기존 방식 - 상대 경로가 복잡함
import { formatDate } from "../../../utils/date";
import { Button } from "../../components/Button";

// ✅ imports 사용 - 간단하고 명확함
import { formatDate } from "#utils/date";
import { Button } from "#components/Button";
```

**TypeScript 설정과 함께 사용:**

```json
// tsconfig.json
{
  "compilerOptions": {
    "paths": {
      "#utils/*": ["./src/utils/*"],
      "#components/*": ["./src/components/*"],
      "#config": ["./src/config/index.ts"]
    }
  }
}
```

`package.json`의 `imports`는 런타임 해석을 담당하고, `tsconfig.json`의 `paths`는 타입 체킹을 담당합니다. 두 설정을 동일하게 유지해야 합니다.

## 모노레포 설계 모범 사례

### 1. 루트에 tsconfig.json이 필요하지 않을 수 있습니다

TypeScript 설정도 패키지로 관리하는 것이 일반적입니다.

**현재 프로젝트 구조:**

```
packages/
└── typescript-config/
    ├── base.json
    ├── nextjs.json
    ├── react-library.json
    └── package.json
```

```json
// packages/typescript-config/base.json
{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

```json
// apps/web/tsconfig.json
{
  "extends": "@repo/typescript-config/nextjs.json",
  "compilerOptions": {
    "jsx": "preserve"
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
```

```json
// packages/math/tsconfig.json
{
  "extends": "@repo/typescript-config/base.json",
  "compilerOptions": {
    "outDir": "./dist"
  },
  "include": ["src/**/*"]
}
```

**장점:**

- 공통 설정을 한 곳에서 관리
- 패키지별로 필요한 설정만 확장
- 설정 변경 시 한 번만 수정하면 모든 패키지에 적용

### 2. 상대 경로로 다른 패키지 접근 금지

패키지 간의 의존성은 반드시 `package.json`의 `dependencies`를 통해 명시해야 합니다.

```typescript
// ❌ 잘못된 방식: 상대 경로로 직접 접근
// apps/web/src/App.tsx
import { Button } from "../../packages/ui/src/Button";
```

**문제점:**

- Turborepo가 의존성을 추적할 수 없음
- 빌드 순서가 보장되지 않음
- 캐싱이 제대로 작동하지 않음

```json
// ✅ 올바른 방식: package.json에 의존성 명시
// apps/web/package.json
{
  "dependencies": {
    "@repo/ui": "workspace:*"
  }
}
```

```typescript
// apps/web/src/App.tsx
import { Button } from "@repo/ui/button";
```

**`workspace:*` 프로토콜:**

- pnpm의 워크스페이스 프로토콜
- 로컬 패키지를 심볼릭 링크로 연결
- 항상 최신 버전을 사용

### 3. 패키지 타입 구분

패키지를 용도에 따라 구분하면 관리가 쉬워집니다.

```
apps/           # 배포 가능한 애플리케이션
├── web/        # Next.js 웹 앱
├── docs/       # 문서 사이트
└── admin/      # 관리자 대시보드

packages/       # 공유 라이브러리
├── ui/         # UI 컴포넌트
├── utils/      # 유틸리티 함수
├── config/     # 공유 설정
└── types/      # 공유 타입 정의
```

## 실전 예제: 새 패키지 추가하기

새로운 유틸리티 패키지를 추가해보겠습니다.

### 1단계: 패키지 디렉토리 생성

```bash
mkdir packages/date-utils
cd packages/date-utils
```

### 2단계: package.json 작성

```json
{
  "name": "@repo/date-utils",
  "type": "module",
  "exports": {
    "./format": "./src/format.ts",
    "./parse": "./src/parse.ts"
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch"
  },
  "devDependencies": {
    "@repo/typescript-config": "workspace:*",
    "typescript": "latest"
  }
}
```

### 3단계: 소스 코드 작성

```typescript
// packages/date-utils/src/format.ts
export const formatDate = (date: Date): string => {
  return date.toISOString().split("T")[0];
};
```

### 4단계: 다른 패키지에서 사용

```json
// apps/web/package.json
{
  "dependencies": {
    "@repo/date-utils": "workspace:*"
  }
}
```

```typescript
// apps/web/app/page.tsx
import { formatDate } from '@repo/date-utils/format';

export default function Page() {
  const today = formatDate(new Date());
  return <div>Today: {today}</div>;
}
```

### 5단계: 빌드 확인

```bash
turbo build
```

Turborepo가 자동으로 의존성을 감지하여 `@repo/date-utils`를 먼저 빌드한 후 `web`을 빌드합니다.

## 정리

Turborepo의 레포지토리 구조는 다음 원칙을 따릅니다:

1. **워크스페이스 기반**: 패키지 매니저의 워크스페이스 기능 활용
2. **명확한 의존성**: `package.json`을 통한 명시적 의존성 선언
3. **exports 활용**: 패키지 진입점을 명확히 정의하여 성능 최적화
4. **설정 공유**: TypeScript, ESLint 등의 설정을 패키지로 관리
5. **상대 경로 금지**: 패키지 간 접근은 항상 패키지 이름으로

이러한 구조를 따르면 Turborepo가 의존성 그래프를 정확히 파악하여 최적의 빌드 순서와 캐싱 전략을 적용할 수 있습니다.

다음 글에서는 `turbo.json`을 통한 태스크 설정과 파이프라인 구성에 대해 자세히 알아보겠습니다.
