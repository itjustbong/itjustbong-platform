---
title: "[Turborepo] 5. 태스크 설정하기 (Configuring Tasks)"
description: "Turborepo 태스크 설정 방법과 모범 사례"
category: "architecture"
tags: ["turborepo", "monorepo", "build", "optimization"]
createdAt: "2025-12-19"
updatedAt: "2025-12-19"
published: true
---


## Turborepo 태스크 설정하기

태스크(Task)는 Turborepo가 실행하는 스크립트입니다. `turbo.json`에서 태스크 간의 관계를 정의하면 Turborepo가 실행 순서와 병렬 처리를 자동으로 결정합니다.

## Turborepo의 병렬 처리 능력

다른 도구들과 비교했을 때 Turborepo의 가장 큰 장점은 **기본적으로 모든 작업을 병렬로 처리**한다는 것입니다.

### 기존 방식 (yarn workspaces)

```bash
yarn workspaces run lint && yarn workspaces run build && yarn workspaces run test
```

**실행 순서:**

```
lint (모든 패키지) → 완료 대기
  ↓
build (모든 패키지) → 완료 대기
  ↓
test (모든 패키지)
```

한 번에 하나의 작업만 진행하므로 시간이 오래 걸립니다.

### Turborepo 방식

```bash
turbo run lint build test
```

**실행 순서:**

```
lint, build, test를 동시에 시작
  ↓
의존성이 있는 경우에만 순서 보장
  ↓
나머지는 모두 병렬 실행
```

필요한 경우에만 순서를 지키고, 나머지는 병렬로 실행하여 시간을 크게 단축합니다.

## 시작하기

### turbo.json에서 태스크 정의

`turbo.json` 파일의 `tasks` 객체에 정의된 각 키는 `turbo run`으로 실행할 수 있는 태스크입니다.

**현재 프로젝트의 실제 설정:**

```json
// turbo.json
{
  "$schema": "https://turborepo.com/schema.json",
  "ui": "tui",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "inputs": ["$TURBO_DEFAULT$", ".env*"],
      "outputs": [".next/**", "!.next/cache/**", "dist/**"]
    },
    "lint": {
      "dependsOn": ["^lint"]
    },
    "check-types": {
      "dependsOn": ["^check-types"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    }
  }
}
```

### 태스크와 스크립트 매핑

Turborepo는 각 패키지의 `package.json`에서 동일한 이름의 스크립트를 찾아 실행합니다.

```
turbo.json의 tasks          →    package.json의 scripts
─────────────────────────────────────────────────────
"build": {...}              →    "build": "next build"
"lint": {...}               →    "lint": "eslint ..."
"dev": {...}                →    "dev": "next dev"
"check-types": {...}        →    "check-types": "tsc --noEmit"
```

**실제 예시:**

```json
// apps/web/package.json
{
  "scripts": {
    "build": "next build",
    "lint": "eslint --max-warnings 0",
    "check-types": "next typegen && tsc --noEmit",
    "dev": "next dev --port 3000"
  }
}
```

```json
// packages/math/package.json
{
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch"
  }
}
```

## 태스크 설정의 중요성

### ❌ 잘못된 설정: 아무 설정도 없는 경우

```json
{
  "tasks": {
    "build": {} // 아무 설정도 없음!
  }
}
```

**문제점:**

1. **빌드 순서 보장 안됨**: 모든 패키지가 동시에 빌드 시작
   - `web`이 `@repo/math`에 의존하는데, `math`가 빌드되기 전에 `web`이 빌드될 수 있음
   - 결과: 빌드 실패!

2. **캐싱 안됨**: `outputs`가 없어서 빌드 결과물이 캐시에 저장되지 않음
   - 매번 처음부터 다시 빌드
   - 시간 낭비

### ✅ 올바른 설정

```json
{
  "tasks": {
    "build": {
      "dependsOn": ["^build"], // 의존성 순서 지정
      "outputs": [".next/**", "dist/**"] // 캐시할 파일 지정
    }
  }
}
```

**실행 순서:**

```
1. packages/math의 build 실행
   → "build": "tsc" 실행
   → dist/ 폴더 생성

2. apps/web의 build 실행 (math가 완료된 후!)
   → "build": "next build" 실행
   → .next/ 폴더 생성

3. 결과물 캐시 저장
   → dist/**, .next/** 파일들을 캐시에 저장
```

## 의존성 관리하기

### ^ 기호: 다른 패키지의 태스크에 의존

`^` 기호는 "이 패키지가 의존하는 다른 패키지들의 태스크를 먼저 실행하라"는 의미입니다.

```json
{
  "tasks": {
    "build": {
      "dependsOn": ["^build"]
    }
  }
}
```

**의존성 그래프:**

```
apps/web (package.json에 "@repo/math": "workspace:*" 의존성 있음)
  ↓ dependsOn: ["^build"]
  ↓
packages/math의 build를 먼저 실행!
```

**실행 예시:**

```bash
$ turbo run build

• Packages in scope: @repo/math, web
• Running build in 2 packages

@repo/math:build: cache miss, executing [1.2s]
web:build: cache miss, executing [8.5s]

Tasks:    2 successful, 2 total
Time:     9.7s
```

### 동일 패키지 내 의존성

`^` 기호 없이 태스크 이름만 명시하면 같은 패키지 내의 태스크에 의존합니다.

```json
{
  "tasks": {
    "test": {
      "dependsOn": ["build"]
    }
  }
}
```

**의미:** "test를 실행하기 전에 같은 패키지의 build를 먼저 실행하라"

**실행 순서:**

```
1. @repo/math:build
2. @repo/math:test

1. web:build
2. web:test
```

## 특정 패키지를 향한 의존성

### 특정 패키지의 태스크에 의존

```json
{
  "tasks": {
    "lint": {
      "dependsOn": ["@repo/math#build"]
    }
  }
}
```

**의미:** "모든 패키지의 lint를 실행하기 전에 `@repo/math` 패키지의 build를 먼저 실행하라"

**실행 순서:**

```bash
$ turbo run lint

1. @repo/math:build 실행
   → "build": "tsc"

2. 모든 패키지의 lint 실행
   → @repo/math:lint
   → @repo/ui:lint
   → web:lint
```

### 특정 패키지의 특정 태스크만 의존성 설정

```json
{
  "tasks": {
    "web#lint": {
      "dependsOn": ["@repo/math#build"]
    }
  }
}
```

**의미:** "web 패키지의 lint만 `@repo/math`의 build에 의존"

**실행 순서:**

```bash
$ turbo run lint

1. @repo/math:build 실행
2. web:lint 실행 (math#build 완료 후)
3. @repo/ui:lint 실행 (독립적으로)
```

### Edge Case: 의존성이 없는데 의존성이 있는 경우

**프로젝트 구조:**

```
apps/
└── web/          (@repo/math에 의존)

packages/
├── math/         (기본 유틸리티)
├── ui/           (@repo/math에 의존)
└── analytics/    (@repo/math에 의존 안 함!)
```

**turbo.json:**

```json
{
  "tasks": {
    "lint": {
      "dependsOn": ["@repo/math#build"]
    }
  }
}
```

**문제:**

```bash
$ turbo run lint

# 모든 패키지의 lint 실행 전:
└─> @repo/math:build 실행 ✓ (강제로!)

# web:lint → math#build 기다림 ✓ (필요함)
# ui:lint → math#build 기다림 ✓ (필요함)
# analytics:lint → math#build 기다림 ⚠️ (불필요한데 기다림!)
```

`analytics`는 `math`에 의존하지 않는데도 `math#build`를 기다려야 합니다.

### 더 정밀한 제어

여러 의존성을 조합하여 정밀하게 제어할 수 있습니다.

```json
{
  "tasks": {
    "web#deploy": {
      "dependsOn": [
        "web#build", // 자기 자신의 build
        "web#test", // 자기 자신의 test
        "@repo/math#build" // math 패키지의 build
      ]
    }
  }
}
```

**실행 순서:**

```bash
$ turbo run web#deploy

1. @repo/math:build
2. web:build (math#build 완료 후)
3. web:test (build 완료 후)
4. web:deploy (모두 완료 후)
```

### 특정 앱에만 특별한 의존성

```json
{
  "tasks": {
    // 일반적인 build는 의존성 기반
    "build": {
      "dependsOn": ["^build"]
    },

    // web 앱의 build만 특별히 analytics도 필요
    "web#build": {
      "dependsOn": [
        "^build", // 일반 의존성
        "@repo/analytics#build" // analytics 추가
      ]
    }
  }
}
```

**실행 순서:**

```bash
$ turbo run build

1. @repo/math:build (web이 의존)
2. @repo/analytics:build (web#build가 명시적 의존)
3. web:build (모두 완료 후)
```

### 의존성이 없는 경우

의존성이 필요 없는 태스크는 `dependsOn`을 생략하거나 빈 배열로 설정합니다.

```json
{
  "tasks": {
    "spell-check": {
      "dependsOn": [] // 또는 생략
    }
  }
}
```

모든 패키지의 `spell-check`가 동시에 병렬로 실행됩니다.

## outputs: 캐싱할 파일 지정

`outputs` 키는 Turborepo에게 어떤 파일과 폴더를 캐싱해야 하는지 알려줍니다.

```json
{
  "tasks": {
    "build": {
      "outputs": [
        ".next/**", // Next.js 빌드 결과
        "!.next/cache/**", // 캐시 폴더는 제외
        "dist/**" // TypeScript 빌드 결과
      ]
    }
  }
}
```

**주의:** `outputs`가 없으면 어떤 빌드 파일도 캐싱되지 않습니다!

**패턴:**

- `**`: 모든 하위 디렉토리
- `!`: 제외 패턴
- `*.js`: 특정 확장자

## inputs: 캐시 키 계산에 사용할 파일

`inputs`는 캐시 키를 생성할 때 어떤 파일을 고려할지 지정합니다.

```json
{
  "tasks": {
    "spell-check": {
      "inputs": ["**/*.md", "**/*.mdx"]
    }
  }
}
```

**동작:**

```
프로젝트 구조:
apps/web/
├── README.md          ✓ 확인함
├── docs/guide.mdx     ✓ 확인함
├── src/page.tsx       ✗ 무시함
└── package.json       ✗ 무시함

packages/math/
├── README.md          ✓ 확인함
└── src/add.ts         ✗ 무시함
```

**결과:**

- `README.md` 변경 → 캐시 미스 (다시 실행)
- `src/page.tsx` 변경 → 캐시 히트 (무시됨)

### 중요한 주의사항: .gitignore와는 별개

#### ❌ 위험한 설정!

```json
{
  "tasks": {
    "build": {
      "inputs": ["**/*.ts", "**/*.tsx"]
    }
  }
}
```

**문제점:**

이 설정은 `node_modules`, `.next`, `dist` 등의 파일도 포함합니다!

- `.gitignore`에 설정이 있어도 무시됨
- 빌드 결과물이 inputs에 포함되어 캐싱이 정상 작동하지 않음

#### ✅ 해결책: $TURBO_DEFAULT$ 사용

`$TURBO_DEFAULT$`는 Turborepo의 기본 동작을 의미합니다.

**기본 동작:**

- ✓ Git이 추적하는 모든 파일
- ✓ `.gitignore` 존중
- ✓ `package.json`
- ✓ `turbo.json`

```json
{
  "tasks": {
    "build": {
      "inputs": ["$TURBO_DEFAULT$", "!README.md"]
    }
  }
}
```

**의미:**

- `$TURBO_DEFAULT$`: 기본 동작 유지
- `!README.md`: 추가로 README.md는 무시

### 실전 예시

```json
{
  "tasks": {
    "build": {
      "inputs": ["$TURBO_DEFAULT$", "!README.md", "!CHANGELOG.md", "!docs/**"]
    }
  }
}
```

**결과:**

```
변경된 파일          캐시 결과
─────────────────────────────
src/app.tsx         캐시 미스 (다시 빌드)
README.md           캐시 히트 (무시됨)
docs/guide.md       캐시 히트 (무시됨)
package.json        캐시 미스 (다시 빌드)
```

## Root 태스크 등록하기

워크스페이스 루트의 `package.json` 스크립트도 Turborepo로 실행할 수 있습니다.

### Root 태스크 문법

```json
{
  "tasks": {
    "lint": {
      // 일반 태스크
      "dependsOn": ["^lint"]
    },
    "//#lint:root": {} // Root 태스크
    // ↑↑  ↑
    // │└─ 구분자
    // └── "루트에서 실행"을 의미
  }
}
```

### 프로젝트 구조

```
my-monorepo/
├── package.json           ← 루트 package.json
├── turbo.json
├── .eslintrc.js          ← 루트 설정 파일
├── apps/
│   └── web/
│       └── package.json
└── packages/
    └── math/
        └── package.json
```

### 실행 예시

```bash
# Root 태스크만 실행
$ turbo run lint:root
✓ //#lint:root: 완료 (2초)

# 모든 lint 태스크 실행 (패키지 + 루트)
$ turbo run lint lint:root
✓ packages/math:lint: 완료 (3초)
✓ apps/web:lint: 완료 (5초)
✓ //#lint:root: 완료 (2초)
```

### 실전 사용 예시

#### 루트 파일 린팅

```json
// package.json (루트)
{
  "scripts": {
    "lint:root": "eslint *.js *.ts *.json"
  }
}

// turbo.json
{
  "tasks": {
    "//#lint:root": {
      "inputs": ["*.js", "*.ts", "*.json"],
      "outputs": []
    }
  }
}
```

#### 전체 타입 체크

```json
// turbo.json
{
  "tasks": {
    "//#typecheck:all": {
      "dependsOn": ["^build"], // 모든 패키지 빌드 후 실행
      "inputs": ["**/*.ts", "**/*.tsx", "tsconfig.json"]
    }
  }
}
```

## 고급 사용 예시

### Package Configuration: 패키지별 설정

루트 `turbo.json`뿐 아니라 각 패키지에도 `turbo.json`을 작성할 수 있습니다.

**구조:**

```
my-monorepo/
├── turbo.json              ← 기본 설정
├── package.json
├── apps/
│   └── web/
│       ├── turbo.json      ← web만의 설정!
│       └── package.json
└── packages/
    └── math/
        ├── turbo.json      ← math만의 설정!
        └── package.json
```

**루트 설정:**

```json
// turbo.json (루트)
{
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [".next/**", "dist/**"]
    },
    "lint": {
      "dependsOn": ["^lint"]
    }
  }
}
```

**패키지별 설정:**

```json
// packages/math/turbo.json
{
  "extends": ["//"], // ← 루트 설정 상속
  "tasks": {
    "build": {
      "outputs": ["dist/**", "types/**"], // math는 types도 생성
      "inputs": ["src/**/*.ts", "!**/*.test.ts"] // 테스트 파일 제외
    }
  }
}
```

**`"extends": ["//"]`의 의미:**

- `//`: 최상위 `turbo.json`을 상속
- 루트 설정을 기본으로 사용하되, 여기서 정의한 것만 덮어씀

### 예시 1: 패키지별 특별한 캐싱 규칙

math 패키지는 README 변경 시에도 재빌드하고 싶은 경우:

```json
// turbo.json (루트)
{
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "inputs": ["$TURBO_DEFAULT$", "!README.md"],  // README 무시
      "outputs": ["dist/**"]
    }
  }
}

// packages/math/turbo.json
{
  "extends": ["//"],
  "tasks": {
    "build": {
      "inputs": ["$TURBO_DEFAULT$"]  // README 포함!
    }
  }
}
```

### 예시 2: 팀별 다른 린트 규칙

```json
// turbo.json (루트)
{
  "tasks": {
    "lint": {
      "outputs": []
    }
  }
}

// apps/web/turbo.json (Frontend 팀)
{
  "extends": ["//"],
  "tasks": {
    "lint": {
      "inputs": ["src/**/*.{ts,tsx}", ".eslintrc.js"],
      "outputs": ["lint-report.json"]
    }
  }
}

// apps/api/turbo.json (Backend 팀)
{
  "extends": ["//"],
  "tasks": {
    "lint": {
      "inputs": ["src/**/*.ts"],
      "cache": false  // 캐시 사용 안 함
    }
  }
}
```

### 예시 3: 개발 서버 설정

각 앱마다 다른 포트와 환경 변수:

```json
// turbo.json (루트)
{
  "tasks": {
    "dev": {
      "cache": false,
      "persistent": true
    }
  }
}

// apps/web/turbo.json
{
  "extends": ["//"],
  "tasks": {
    "dev": {
      "env": ["NEXT_PUBLIC_API_URL", "PORT"],
      "inputs": ["src/**", ".env.local"]
    }
  }
}

// apps/docs/turbo.json
{
  "extends": ["//"],
  "tasks": {
    "dev": {
      "env": ["VITE_API_URL"],
      "inputs": ["src/**", "vite.config.ts"]
    }
  }
}
```

## 장기 실행 태스크 with 런타임 의존성

개발 서버처럼 계속 실행되는 태스크의 의존성을 다루는 방법입니다.

### ❌ 잘못된 방식: dependsOn 사용

```json
{
  "tasks": {
    "dev": {
      "dependsOn": ["api#dev"] // api#dev가 절대 끝나지 않음!
    }
  }
}
```

**문제:**

- `api#dev`는 개발 서버라서 계속 실행됨
- `web#dev`는 `api#dev`가 끝나기를 기다림
- 결과: `web#dev`가 절대 시작되지 않음!

### ✅ 올바른 방식: with 사용

```json
{
  "tasks": {
    "dev": {
      "persistent": true,
      "cache": false
    },
    "web#dev": {
      "with": ["api#dev"] // 동시에 실행!
    }
  }
}
```

**실행 순서:**

```bash
$ turbo run web#dev

✓ api#dev 시작 (포트 3001에서 실행)
✓ web#dev 시작 (포트 3000에서 실행)

두 서버가 동시에 실행됨!
```

### dependsOn vs with의 차이

```
dependsOn: "A가 끝난 후에 B를 실행" (순차적)
with: "A와 B를 동시에 실행" (병렬적)
```

**사용 예시:**

```json
{
  "tasks": {
    "web#dev": {
      "dependsOn": ["@repo/ui#build"], // ui는 먼저 빌드
      "with": ["api#dev"] // api는 동시에 실행
    }
  }
}
```

**실행 순서:**

```
1. @repo/ui:build (완료 대기)
2. api:dev 시작 (계속 실행)
3. web:dev 시작 (계속 실행)
```

## 부수 효과 수행하기

어떤 태스크는 캐싱에 상관없이 항상 실행되어야 합니다.

### 문제 상황

```json
{
  "tasks": {
    "deploy": {
      "dependsOn": ["^build"],
      "outputs": [] // outputs가 없음
    }
  }
}
```

**문제:**

- 첫 실행: 배포 성공
- 두 번째 실행: 코드 변경 없음 → 캐시 히트 → 배포 건너뜀!
- 결과: 배포가 실행되지 않음

### 해결책: cache: false

```json
{
  "tasks": {
    "deploy": {
      "dependsOn": ["^build"],
      "cache": false // 항상 실행!
    },
    "build": {
      "outputs": ["dist/**"]
    }
  }
}
```

**동작:**

```bash
$ turbo run deploy

# 첫 실행
@repo/math:build → 캐시 미스, 실행
web:deploy → 항상 실행 (cache: false)

# 두 번째 실행 (코드 변경 없음)
@repo/math:build → 캐시 히트, 건너뜀
web:deploy → 항상 실행! (cache: false)
```

### cache: false가 필요한 경우

**파일 시스템 외부의 변경사항:**

- 배포 (Vercel, AWS 등)
- DB 마이그레이션
- 외부 API 호출
- 네트워크 요청
- 시스템 설정 변경

**예시:**

```json
{
  "tasks": {
    "deploy": {
      "cache": false
    },
    "db:migrate": {
      "cache": false
    },
    "publish": {
      "cache": false
    }
  }
}
```

## Transit Node: 병렬 실행 가능한 의존 태스크

일부 태스크는 다른 패키지에 의존하지만 실제로는 병렬로 실행 가능합니다. 대표적인 예가 타입 체크입니다.

### 문제 상황

**시나리오:**

1. `@repo/math` 패키지의 `add` 함수를 수정
   - `add(a, b)` → `add(a, b, c)`로 변경
2. `web` 앱은 여전히 `add(10, 5)`로 호출 (인자 2개)
3. 타입 에러 발생해야 함!

### 해결 방법 1: 아무것도 확인 안함 (❌)

```json
{
  "tasks": {
    "check-types": {}
  }
}
```

```bash
$ turbo run check-types

@repo/math:check-types → 타입 체크 ✓
web:check-types → 캐시 사용 ✓ (잘못됨!)
```

**문제:**

- `math` 패키지만 변경되었기 때문에 `web`의 타입 체크는 캐시를 활용
- `web`의 타입 에러를 발견하지 못함!

### 해결 방법 2: 순차적으로 진행 (❌)

```json
{
  "tasks": {
    "check-types": {
      "dependsOn": ["^check-types"]
    }
  }
}
```

```bash
$ turbo run check-types

1. @repo/math:check-types (2초)
2. math 끝날 때까지 기다림...
3. web:check-types (3초)

총 시간: 5초
```

**문제:**

- 타입 에러는 발견하지만 순차적으로 실행되어 느림
- 실제로는 병렬로 실행해도 되는데 기다려야 함

### 해결 방법 3: Transit Node (✅)

```json
{
  "tasks": {
    "transit": {
      "dependsOn": ["^transit"]
    },
    "check-types": {
      "dependsOn": ["transit"]
    }
  }
}
```

```bash
$ turbo run check-types

@repo/math:check-types (2초) ┐
web:check-types (3초)         ┘ 동시에!

총 시간: 3초
```

**장점:**

- 타입 에러를 정확히 발견
- 병렬로 실행되어 빠름

### Transit Node란?

Transit Node는 **가상 태스크**입니다.

**특징:**

- 실제로 실행되지 않음 (`package.json`에 스크립트 없음)
- 의존성 추적만 담당
- 실제 태스크들은 동시에 실행 가능

**이름:**

- `transit` (일반적)
- `#` 접두사 (Vercel 스타일)
- 아무 이름이나 가능 (단, `package.json`에 없는 이름)

### Transit Node 동작 원리

#### web 패키지 실행 시

```
1. web의 check-types는 transit에 의존
   → transit 먼저 확인해야 함

2. web의 transit은 "^transit"에 의존
   → math의 transit 확인해야 함

3. math의 transit 해시 계산
   math 패키지 파일들 → "math-transit-999" ← 바뀜!

4. math의 transit 캐시 확인
   "math-transit-999" → 없음!
   → math가 변경됨을 감지!

5. web의 transit도 무효화됨
   (의존성이 바뀌었으니까)

6. web의 check-types도 무효화됨
   (transit이 바뀌었으니까)

7. 다시 실행!
```

#### 의존성 체인

```
1. math 파일 변경
   ↓
2. math의 transit 해시 변경
   ↓
3. web의 transit 해시 변경 (의존성 때문에)
   ↓
4. web의 check-types 해시 변경 (의존성 때문에)
   ↓
5. web의 check-types 다시 실행!
```

### Transit은 package.json에 없는데?

**Turborepo의 사고 과정:**

```
1. "check-types를 실행해야 하는구나"

2. "check-types는 transit에 의존하네?"
   → transit을 먼저 확인해야겠다

3. math/package.json 확인
   {
     "scripts": {
       "transit": "???"  ← 없음!
     }
   }

4. "아, transit 스크립트가 없네?"
   → "그럼 실행할 게 없구나"
   → "그냥 넘어가자" ✓

5. "하지만 해시는 계산해야지!"
   → math 패키지 파일들의 해시 계산
   → transit의 해시로 저장

6. "이제 check-types 실행!"
```

### 실전 예시

**현재 프로젝트에 적용:**

```json
// turbo.json
{
  "tasks": {
    "transit": {
      "dependsOn": ["^transit"]
    },
    "check-types": {
      "dependsOn": ["transit"]
    },
    "lint": {
      "dependsOn": ["transit"]
    }
  }
}
```

**실행:**

```bash
$ turbo run check-types lint

# 병렬 실행:
@repo/math:check-types (2초) ┐
@repo/math:lint (1초)         │ 동시에!
web:check-types (3초)         │
web:lint (2초)                ┘

총 시간: 3초 (가장 긴 태스크 기준)
```

**Transit Node 없이 실행했다면:**

```bash
# 순차 실행:
1. @repo/math:check-types (2초)
2. @repo/math:lint (1초)
3. web:check-types (3초)
4. web:lint (2초)

총 시간: 8초
```

## 실전 종합 예시

현재 프로젝트의 완전한 `turbo.json` 설정:

```json
{
  "$schema": "https://turborepo.com/schema.json",
  "ui": "tui",
  "tasks": {
    // 빌드: 의존성 순서 보장, 캐싱 활성화
    "build": {
      "dependsOn": ["^build"],
      "inputs": ["$TURBO_DEFAULT$", ".env*"],
      "outputs": [".next/**", "!.next/cache/**", "dist/**"]
    },

    // Transit Node: 의존성 추적용
    "transit": {
      "dependsOn": ["^transit"]
    },

    // 린트: 병렬 실행, 의존성 변경 감지
    "lint": {
      "dependsOn": ["transit"]
    },

    // 타입 체크: 병렬 실행, 의존성 변경 감지
    "check-types": {
      "dependsOn": ["transit"]
    },

    // 개발 서버: 캐싱 비활성화, 장기 실행
    "dev": {
      "cache": false,
      "persistent": true
    },

    // 배포: 항상 실행
    "deploy": {
      "dependsOn": ["build", "check-types", "lint"],
      "cache": false
    },

    // 루트 린트
    "//#lint:root": {
      "inputs": ["*.js", "*.ts", "*.json"],
      "outputs": []
    }
  }
}
```

**실행 예시:**

```bash
# 전체 빌드
$ turbo run build
@repo/math:build → 1.2s
web:build → 8.5s
총 시간: 9.7s

# 타입 체크 + 린트 (병렬)
$ turbo run check-types lint
@repo/math:check-types → 0.8s ┐
@repo/math:lint → 0.5s        │ 동시에!
web:check-types → 2.1s        │
web:lint → 1.3s               ┘
총 시간: 2.1s

# 개발 서버
$ turbo run dev
@repo/math:dev → 시작 (watch 모드)
web:dev → 시작 (포트 3000)
계속 실행 중...

# 배포
$ turbo run deploy
@repo/math:build → 캐시 히트
web:build → 캐시 히트
web:check-types → 캐시 히트
web:lint → 캐시 히트
web:deploy → 항상 실행 (cache: false)
```

## 정리

Turborepo 태스크 설정의 핵심 개념:

1. **dependsOn**: 태스크 간 의존성 정의
   - `^build`: 다른 패키지의 태스크
   - `build`: 같은 패키지의 태스크
   - `@repo/math#build`: 특정 패키지의 태스크

2. **outputs**: 캐싱할 파일 지정
   - 빌드 결과물 경로 명시
   - 제외 패턴 사용 가능 (`!`)

3. **inputs**: 캐시 키 계산에 사용할 파일
   - `$TURBO_DEFAULT$`: 기본 동작
   - 추가 제외 패턴 가능

4. **cache**: 캐싱 활성화/비활성화
   - `false`: 항상 실행 (배포, DB 마이그레이션 등)

5. **persistent**: 장기 실행 태스크
   - 개발 서버, watch 모드 등

6. **with**: 동시 실행
   - 장기 실행 태스크의 의존성

7. **Transit Node**: 병렬 실행 가능한 의존성
   - 의존성 변경 감지
   - 실제 태스크는 병렬 실행

8. **Package Configuration**: 패키지별 설정
   - `extends`: 루트 설정 상속
   - 패키지별 커스터마이징

이러한 설정을 통해 Turborepo는 빌드 순서와 병렬 처리를 자동으로 결정합니다.

다음 글에서는 Turborepo의 캐싱 메커니즘과 원격 캐싱 설정을 다룹니다.
