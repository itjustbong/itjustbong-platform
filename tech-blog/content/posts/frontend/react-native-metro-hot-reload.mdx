---
title: "[React Native] Metro 서버와 Hot Reload 원리"
description: "React Native의 핵심 번들러 Metro 서버의 역할과 Hot Reload가 작동하는 원리"
category: "frontend"
tags: ["react native", "expo", "metro", "hot reload"]
createdAt: "2026-01-19"
updatedAt: "2026-01-19"
published: true
---

## Metro 서버와 Hot Reload 원리

Metro 서버의 역할과 Hot Reload가 어떻게 작동하는지 정리합니다.

<Toc>
1. [Metro 서버란?](#metro-서버란)
2. [Metro의 주요 역할](#metro의-주요-역할)
3. [Metro 서버가 필요한 이유](#metro-서버가-필요한-이유)
4. [Hot Reload가 가능한 이유](#hot-reload가-가능한-이유)
5. [Development Build에서 Hot Reload가 되는 원리](#development-build에서-hot-reload가-되는-원리)
6. [왜 Preview/Production에서는 Metro가 필요 없을까?](#왜-previewproduction에서는-metro가-필요-없을까)
</Toc>

---

## Metro 서버란?

Metro는 React Native와 Expo의 **공식 JavaScript 번들러**입니다. 웹 개발에서 Webpack이나 Vite가 하는 역할과 비슷합니다.

```mermaid
flowchart LR
    A[JavaScript/TypeScript 코드] --> B[Metro Bundler]
    C[Assets 이미지/폰트] --> B
    B --> D[번들된 JavaScript]
    D --> E[네이티브 앱에서 실행]
```

---

## Metro의 주요 역할

| 기능                | 설명                                      |
| ------------------- | ----------------------------------------- |
| **코드 번들링**     | 여러 JS/TS 파일을 하나의 번들로 합침      |
| **Hot Reload**      | 코드 변경 시 앱을 새로고침 없이 즉시 반영 |
| **Fast Refresh**    | 컴포넌트 상태를 유지하면서 변경사항 반영  |
| **Asset 처리**      | 이미지, 폰트 등의 리소스 처리             |
| **TypeScript 지원** | TS 코드를 JS로 변환                       |

### Metro 서버 시작 방법

```bash
npx expo start
```

이 명령어를 실행하면 기본적으로 `http://localhost:8081`에서 Metro 서버가 시작됩니다.

---

## Metro 서버가 필요한 이유

### 개발 모드 (Expo Go / Development Build)

개발 중에는 JavaScript 코드를 **실시간으로 수정하고 테스트**해야 합니다. 이때 Metro 서버가 핵심 역할을 합니다.

```mermaid
sequenceDiagram
    participant Dev as 👨‍💻 개발자
    participant Metro as 🖥️ Metro 서버
    participant App as 📱 앱 (네이티브)

    Dev->>Metro: 1. npx expo start
    Metro->>Metro: 2. JS 파일 감시 시작
    App->>Metro: 3. 앱 실행 시 JS 번들 요청
    Metro->>App: 4. JS 번들 전송
    App->>App: 5. JS 실행하여 UI 렌더링

    Note over Dev,App: 🔄 Hot Reload 과정
    Dev->>Dev: 6. 코드 수정 (Button.tsx)
    Dev->>Metro: 7. 파일 변경 감지
    Metro->>Metro: 8. 변경된 모듈만 재번들링
    Metro->>App: 9. 변경된 부분만 전송 (WebSocket)
    App->>App: 10. 상태 유지하며 UI 업데이트
```

### Metro 서버의 역할 정리

```mermaid
flowchart TB
    subgraph Metro 서버 역할
        A[파일 감시] --> B[변경 감지]
        B --> C[증분 번들링]
        C --> D[WebSocket으로 앱에 전송]
        D --> E[앱에서 새 번들 적용]
    end

    F[개발자 코드 수정] --> A
    E --> G[화면 즉시 업데이트]
```

**Metro 서버가 하는 일:**

1. **파일 감시 (Watch)**: 프로젝트의 모든 JS/TS 파일 변경 감시
2. **번들링 (Bundle)**: 변경된 파일만 빠르게 재번들링
3. **전송 (Serve)**: WebSocket을 통해 앱에 새 코드 전송
4. **HMR (Hot Module Replacement)**: 상태를 유지하면서 변경된 모듈만 교체

---

## Hot Reload가 가능한 이유

**핵심 포인트**: JavaScript 코드는 **인터프리터 언어**이기 때문에 컴파일 없이 즉시 실행할 수 있습니다!

```mermaid
flowchart LR
    subgraph 네이티브 코드
        A[Swift/Kotlin] --> B[컴파일] --> C[바이너리]
    end

    subgraph JavaScript 코드
        D[JS/TS 코드] --> E[번들링만] --> F[즉시 실행 가능]
    end

    style B fill:#FF6347
    style E fill:#90EE90
```

| 언어                    | 실행 방식                | 변경 시                  |
| ----------------------- | ------------------------ | ------------------------ |
| Swift/Kotlin (네이티브) | 컴파일 → 바이너리        | 전체 재빌드 필요 (수 분) |
| JavaScript              | 번들링 → 인터프리터 실행 | 번들만 교체 (수 초)      |

---

## Development Build에서 Hot Reload가 되는 원리

이 부분이 가장 헷갈리는 부분이죠! **"빌드가 필요한데 어떻게 Hot Reload가 가능하지?"**

### 핵심 이해: 빌드는 네이티브만!

```mermaid
flowchart TB
    subgraph 한번만빌드["🔨 한 번만 빌드 (네이티브)"]
        A[네이티브 코드]
        B[expo-dev-client]
        C[커스텀 네이티브 라이브러리]
        A --> D[Development Build APK/IPA]
        B --> D
        C --> D
    end

    subgraph 계속변경["🔄 계속 변경 가능 (JavaScript)"]
        E[React 컴포넌트]
        F[비즈니스 로직]
        G[스타일]
        E --> H[Metro 서버]
        F --> H
        G --> H
    end

    D <-->|실시간 연결| H

    style D fill:#FFB6C1
    style H fill:#98FB98
```

### 비유로 이해하기 🎮

> Development Build는 **게임기 본체를 한 번 조립**하는 것과 같습니다.
>
> 1. **게임기 조립 (빌드)**: 한 번만 하면 됨
>
>    - 원하는 컨트롤러 추가 (네이티브 라이브러리)
>    - 특수 기능 추가 (카메라, GPS 등)
>
> 2. **게임 카트리지 교체 (Hot Reload)**: 무한히 가능
>    - 게임기를 다시 조립할 필요 없음
>    - 카트리지(JS)만 바꾸면 됨

### 실제 워크플로우

```mermaid
sequenceDiagram
    participant Dev as 👨‍💻 개발자
    participant Build as 🔨 빌드 시스템
    participant Phone as 📱 디바이스
    participant Metro as 🖥️ Metro 서버

    Note over Dev,Metro: 1️⃣ 최초 1회: Development Build 생성
    Dev->>Build: npx expo run:ios (또는 eas build)
    Build->>Build: 네이티브 코드 컴파일 (5-10분)
    Build->>Phone: Development Build 설치

    Note over Dev,Metro: 2️⃣ 이후: Hot Reload로 개발
    Dev->>Metro: npx expo start
    Phone->>Metro: Metro 서버에 연결

    loop 개발 중 (무한 반복)
        Dev->>Dev: JS 코드 수정
        Metro->>Phone: 변경사항 즉시 전송
        Phone->>Phone: 화면 업데이트 (1-2초)
    end

    Note over Dev,Metro: 3️⃣ 네이티브 변경 시에만 재빌드
    Dev->>Dev: 새 네이티브 라이브러리 추가
    Dev->>Build: npx expo run:ios (재빌드)
```

### 언제 재빌드가 필요한가?

| 변경 내용                      | 재빌드 필요? | 이유                 |
| ------------------------------ | ------------ | -------------------- |
| 버튼 색상 변경                 | ❌           | JS 코드 (Hot Reload) |
| 새 화면 추가                   | ❌           | JS 코드 (Hot Reload) |
| API 호출 로직 변경             | ❌           | JS 코드 (Hot Reload) |
| 새 npm 패키지 (JS만)           | ❌           | JS 코드 (Hot Reload) |
| **react-native-firebase 추가** | ✅           | 네이티브 코드 포함   |
| **카메라 권한 설정 변경**      | ✅           | 네이티브 설정        |
| **앱 아이콘 변경**             | ✅           | 네이티브 리소스      |
| **Expo SDK 업그레이드**        | ✅           | 네이티브 코드 변경   |

### 정리: Development Build의 장점

```mermaid
flowchart LR
    A[Development Build] --> B[네이티브 자유도]
    A --> C[Hot Reload 유지]
    A --> D[디버깅 도구]

    B --> B1[어떤 라이브러리든 사용]
    C --> C1[빠른 개발 속도]
    D --> D1[expo-dev-client 메뉴]

    style A fill:#87CEEB
```

**Development Build = 네이티브 자유도 + Hot Reload의 편리함**

- Expo Go처럼 빠른 개발 (Hot Reload)
- 하지만 네이티브 제한 없음 (커스텀 라이브러리 사용 가능)
- 네이티브 변경 시에만 재빌드 (보통 드묾)

---

## 왜 Preview/Production에서는 Metro가 필요 없을까?

### 배포 빌드의 구조

Preview와 Production 빌드에서는 **JavaScript 번들이 앱 안에 내장**됩니다!

```mermaid
flowchart TB
    subgraph 개발모드["🔧 개발 모드 (Expo Go / Dev Build)"]
        A1[네이티브 앱] <-->|네트워크 연결| B1[Metro 서버]
        B1 --> C1[JS 번들 실시간 제공]
    end

    subgraph 배포모드["📦 배포 모드 (Preview / Production)"]
        A2[네이티브 앱]
        B2[내장된 JS 번들]
        A2 --> B2
    end

    style B1 fill:#87CEEB
    style B2 fill:#FFD700
```

### 비유로 이해하기 📺

> **개발 모드** = 넷플릭스 스트리밍
>
> - 영상(JS)을 서버(Metro)에서 실시간으로 받아옴
> - 인터넷 연결 필수
> - 영상 변경 시 바로 반영
>
> **배포 모드** = DVD에 구운 영화
>
> - 영상(JS)이 디스크(앱) 안에 들어있음
> - 인터넷 연결 불필요
> - 영상 변경하려면 새 DVD 필요 (새 빌드)

### 빌드 과정 비교

```mermaid
flowchart TB
    subgraph 개발빌드["개발 빌드"]
        A1[JS 코드] --> B1[Metro 서버에서 제공]
        C1[네이티브 코드] --> D1[앱에 포함]
        B1 -.->|실시간 연결| E1[실행 중인 앱]
        D1 --> E1
    end

    subgraph 배포빌드["배포 빌드"]
        A2[JS 코드] --> B2[번들로 컴파일]
        C2[네이티브 코드] --> D2[앱에 포함]
        B2 --> E2[앱에 내장]
        D2 --> F2[최종 앱 패키지]
        E2 --> F2
    end

    style B1 fill:#87CEEB
    style E2 fill:#FFD700
```

| 구분             | 개발 빌드         | 배포 빌드      |
| ---------------- | ----------------- | -------------- |
| **JS 번들 위치** | Metro 서버 (외부) | 앱 내부 (내장) |
| **Metro 필요**   | ✅ 필수           | ❌ 불필요      |
| **Hot Reload**   | ✅ 가능           | ❌ 불가능      |
| **인터넷 필요**  | ✅ 개발 서버 연결 | ❌ 독립 실행   |
| **JS 변경 시**   | 즉시 반영         | 새 빌드 필요   |

---

## 마무리

Metro 서버는 JavaScript 번들러이자 실시간 코드 전송 역할을 합니다. 개발 중에는 Metro가 변경된 JS를 앱에 전송하고, 배포 빌드에서는 JS 번들이 앱에 내장되어 Metro 없이 독립 실행됩니다.
